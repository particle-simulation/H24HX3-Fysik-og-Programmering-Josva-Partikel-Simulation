package processing.test.particle_simulation;

/* autogenerated by Processing revision 1296 on 2025-04-24 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorManager;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Particle_Simulation extends PApplet {







Context context;
SensorManager manager;
Sensor sensor;
AccelerometerListener listener;
GUI gui; //declare GUI

ParticleSystem ps;
PVector gravityDirection = new PVector(0, 0); // direction of gravity from accelerometer
PVector gravity = new PVector(0, 0); // actual gravity force applied to particles
int simX = 855; // X position of simulation area
int simY = 45;  // Y position of simulation area
int simW = 990; // Width of simulation area
int simH = 990; // Height of simulation area

int value = 0;
boolean firstMousePress = false;

public void setup() {
  /* size commented out by preprocessor */;
  orientation(LANDSCAPE);
  gui=new GUI(); //initiate GUI class
  textSize(50);
  ps = new ParticleSystem(gui.slider2.getValue()); // Initial number of particles

  context = getActivity(); // get Android context
  manager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE); // get sensor manager
  sensor = manager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); // use accelerometer sensor
  listener = new AccelerometerListener(); // create new sensor event listener
  manager.registerListener(listener, sensor, SensorManager.SENSOR_DELAY_GAME); // register listener
}


public void draw() {
  background(0);
  gui.drawGUI();  // draws the UI

  // Update gravity based on slider1 value (0–10G)
  float gravityMagnitude = gui.slider1.getValue() * 0.2f; // scale G (adjust if needed)
  gravity.set(gravityDirection.copy().mult(gravityMagnitude)); // set gravity vector
  ps.setGravity(gravity); // apply gravity to particle system

  // Check if slider2 changed, recreate ParticleSystem
  int desiredParticles = gui.slider2.getValue();
  if (ps.numParticles != desiredParticles) {
    ps = new ParticleSystem(desiredParticles); // recreate system if count changed
  }

 
  pushMatrix(); // isolate transformations
  translate(simX, simY); // Shift origin to simulation area
  ps.update();
  ps.display(); //draw particles
  popMatrix();
}

class AccelerometerListener implements SensorEventListener {
  public void onSensorChanged(SensorEvent event) {
    // Android landscape: event.values[0] = left-right, [1] = up-down, [2] = Z
    gravityDirection.set(event.values[1], event.values[0]); // Invert X because phone is in landscape
    gravityDirection.normalize();
  }

  public void onAccuracyChanged(Sensor sensor, int accuracy) {
  }
}

public void mousePressed() {
  if (!firstMousePress) {
    firstMousePress = true;
  }
}
class GUI { //static GUI elements
  //Attributes
  int settingsWindowHeight = 800;
   int settingsWindowWidth = 990;
   int particleWindowHeight = 990;
   int particleWindowWidth = 990;
  Slider slider1 = new Slider(settingsWindowWidth/2-350,settingsWindowHeight,"Tyngdekraft");
  Slider slider2 = new Slider(settingsWindowWidth/2-350,settingsWindowHeight-175,"Partikler");
  //Constructor
  //Methods
  public void drawGUI(){
    fill(45);
    rect(45,45,settingsWindowHeight,settingsWindowWidth);
    rect(855,45,particleWindowHeight,particleWindowWidth);
    slider1.update();
    slider2.update();
    slider1.drawSlider();
    slider2.drawSlider();
  }
}
class Particle {
  // Position of the particle in 2D space
  PVector position;
  
  // Velocity of the particle, representing its speed and direction
  PVector velocity;
  
  // Acceleration of the particle, representing the change in velocity
  PVector acceleration;
  
  // Radius of the particle, used for rendering and collision detection
  float radius = 10;

  // Constructor to initialize the particle with a specific position
  Particle(float x, float y) {
    position = new PVector(x, y); // Set the initial position of the particle
    // Initialize velocity with random values for a more dynamic effect
    velocity = new PVector(random(-1, 1), random(-2, 0)); 
    acceleration = new PVector(0, 0); // Start with no acceleration
  }

  // Apply a force to the particle, affecting its acceleration
  public void applyForce(PVector force) {
    acceleration.add(force); // Add the force to the current acceleration
  }

  // Update the particle's position and velocity based on its acceleration
  public void update() {
    velocity.add(acceleration); // Update velocity based on acceleration
    position.add(velocity); // Update position based on velocity
    acceleration.mult(0); // Reset acceleration for the next frame
  }

  // Check if the particle has hit the edges of the window and apply damping
 public void checkEdges(float damping) {
  // Horizontal edges
  if (position.x < radius) {
    position.x = radius;
    velocity.x *= -damping;
  } else if (position.x > simW - radius) {
    position.x = simW - radius;
    velocity.x *= -damping;
  }

  // Vertical edges
  if (position.y < radius) {
    position.y = radius;
    velocity.y *= -damping;
  } else if (position.y > simH - radius) {
    position.y = simH - radius;
    velocity.y *= -damping;
  }
}


  // Render the particle on the screen
  public void display() {
    fill(100, 150, 255); // Set the fill color for the particle
    stroke(50); // Set the stroke color for the outline
    // Draw the particle as a circle at its position
    ellipse(position.x, position.y, radius * 2, radius * 2);
  }
}
class ParticleSystem {
  // Array to hold all the particles in the system
  Particle[] particles;

  // Total number of particles in the system
  int numParticles;

  // Vector representing the gravitational force applied to the particles
  PVector gravity;

  // Radius within which particles will interact with each other
  float interactionRadius = 30;

  // Strength of the repulsion force between particles
  float repulsionStrength = 0.5f;

  // Damping factor to reduce the velocity of particles over time
  float damping = 0.7f;

  // Constructor to initialize the particle system with a specified number of particles
  ParticleSystem(int count) {
    numParticles = count; // Set the number of particles
    gravity = new PVector(0, 0.2f); // Initialize gravity vector
    particles = new Particle[numParticles]; // Create an array for particles
    reset(); // Initialize particle positions
  }

  // Update the state of the particle system
  public void update() {
    for (int i = 0; i < numParticles; i++) {
      particles[i].applyForce(gravity);

      for (int j = 0; j < numParticles; j++) {
        if (i != j) {
          PVector dir = PVector.sub(particles[i].position, particles[j].position);
          float d = dir.mag();
          if (d < interactionRadius && d > 0) {
            dir.normalize();
            float force = repulsionStrength / d;
            particles[i].applyForce(dir.mult(force));
          }
        }
      }

      particles[i].update();
      particles[i].checkEdges(damping); // Check inside sim area
    }
  }

  public void reset() {
    for (int i = 0; i < numParticles; i++) {
      particles[i] = new Particle(simW/2, simH/2); // local to simulation box
    }
  }


  // Display all particles in the system
  public void display() {
    for (Particle p : particles) {
      p.display(); // Call the display method for each particle
    }
  }


  // Set a new gravity vector for the particle system
  public void setGravity(PVector g) {
    gravity.set(g); // Update the gravity vector
  }
}
class Slider {
  String sliderName; // Label for the slider
  int hojde = 50; // Height of the slider
  int laengde = 600; // Length of the slider
  PVector pos; // position of the slider
  PVector sliderPos; // Position of the slider knob
  int loose = 10;  // Controls how smoothly the slider knob moves (higher = smoother)
  boolean over = false; // True if mouse is over the slider
  boolean locked = false; // True if slider is currently being dragged
  float newspos; // Target position for the slider knob

  // Constructor
  Slider(int x, int y, String sliderN) {
    pos = new PVector(x, y); // Set slider position
    sliderName = sliderN; // Store the name
    sliderPos = new PVector(pos.x + random(laengde), y); // Random starting position of slider
    newspos = sliderPos.x; // Set starting position
  }

  // Draws the slider UI
  public void drawSlider() {
    fill(255);
    text(sliderName + ": " + getValue(), pos.x, pos.y - 10); // Show name + current value
    fill(125);
    rect(pos.x, pos.y, laengde, hojde); // Draw the background bar
    fill(over || locked ? color(0) : color(255)); // Change knob color when hovered or locked
    rect(sliderPos.x, sliderPos.y, 30, hojde); // Draw the slider knob
  }

  // Smoothly moves the slider knob and handles interaction
  public void update() {
    over = overEvent(); // Check if mouse is over

    if (firstMousePress && over) {
      locked = true; 
    }
    if (!mousePressed) {
      locked = false; 
    }

    if (locked) {
      newspos = constrain(mouseX - 15, pos.x, pos.x + laengde - 30); // Set knob pos
    }

    if (abs(newspos - sliderPos.x) > 1) {
      sliderPos.x += (newspos - sliderPos.x) / loose; // Smooth interpolation to target. 
    }
  }

  // Maps the knob position to an integer value between 0–11
  public int getValue() {
    return PApplet.parseInt(map(sliderPos.x, pos.x, pos.x + laengde - 30, 0, 11));
  }

  // Detects if mouse is within slider bounds
  public boolean overEvent() {
    return mouseX > pos.x && mouseX < pos.x + laengde &&
      mouseY > pos.y && mouseY < pos.y + hojde;
  }
}


  public void settings() { fullScreen(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Particle_Simulation" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
